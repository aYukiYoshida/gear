********************************************************************************
(ba|z)sh
********************************************************************************
================================================================================
OPTIONS
================================================================================
書式			説明
--------------------------------------------------------------------------------
-u			未定義変数を検出: nounset
-n			コマンドは実行されずに文法のみをチェック
-f			*(アスタリスク)等によるパス名展開の無効化: noglob
-e			終了ステータスが0以外のものが検出した時点でスクリプトを終了
-x			スクリプトの実行内容を出力できる: trace

================================================================================
変数操作
================================================================================
書式			説明
--------------------------------------------------------------------------------
${変数#文字列}		変数にセットされた値の先頭から「文字列」を削除。"#"の場合は最短一致。
${変数##文字列}		"##"の場合は最長一致。
			注)「文字列」にワイルドカードを使用すると、
		   	複数の部分に一致することがある。
		   	例えば、"abcab"と変数をセットしたとすると、
		   	先頭から"a*b"で最短一致するのは、"ab"    > 出力は"cab" 
			先頭から"a*b"で最長一致するのは、"abcab" > 出力は" "(空)


${変数%文字列}		変数にセットされた値の末尾から「文字列」を削除。"%"の場合は最短一致。
${変数%%文字列}		"%%"の場合は最長一致。
			注)「文字列」にワイルドカードを使用すると,
		   	複数の部分に一致することがある。
		   	例えば,"abcab"と変数をセットしたとすると,
			末尾から"a*b"で最短一致するのは、"ab"    > 出力は"abc"
			末尾から"a*b"で最長一致するのは、"abcab" > 出力は" "(空)
		   
${変数:開始位置} 	開始位置(先頭:0)から最後までの部分文字列
			ex) test=abcab ${test:1} > bcab
${変数:開始位置:長さ}	開始位置(先頭:0)から長さ分の部分文字列
			ex) test=abcab ${test:1:2} > bc

${変数/パターン/置換}	最初にみつけたパターンを置換
${変数//パターン/置換}	見つかった全てのパターンを置換


${変数名:-文字列}	変数が存在し空でなければその値、それ以外なら文字列
${変数名:=文字列}	変数が存在し空でなければその値、それ以外なら変数に文字列を設定
${変数名:?文字列}	変数が存在し空でなければその値、それ以外なら文字列を出力して終了
${変数名:+文字列}	変数が存在し空でなければその文字列、それ以外なら空


================================================================================
特殊変数
================================================================================
変数名		説明
--------------------------------------------------------------------------------
$0		実行したコマンド名(フルパス)
$1,$2,${10}	1,2,10番目の引数(2桁の場合は{}で囲む)
$#		現在のプロセスに与えられた引数の数
$?		直前に実行したコマンドの終了ステータス.
$PIPESTATUS	パイプで連結した各コマンドの終了ステータスが設定される変数.
$$		実行シェルのプロセス番号(PID)を格納する変数.
$!		最後に呼び出されたバックグラウンドプロセスのプロセス番号を格納する変数.
$@		現在のプロセスに与えられた引数。
		二重符で囲まれている場合、
		それぞれの引数の値を正確に表すように展開される。
${@:X:Y}	複数のパラメータのうち、X番目以降のY個のデータを取得するための変数を格納する変数.
$*		現在のプロセスに与えられた引数。
		二重符で囲まれている場合、
		連結されてひとつの変数へと展開される。
$LINENO		この変数を使用している行の行番号が設定される変数.


${#string}	変数に格納された文字数を表す。
		ex) $ string=abcde
		    $ echo ${#string}
		    5


================================================================================
評価演算子
================================================================================
形式		条件
--------------------------------------------------------------------------------
-b　ファイル名	指定したファイルがブロックデバイスファイルなら真である。
-c　ファイル名	指定したファイルがキャラクタデバイスファイルなら真である。
-d　ファイル名	指定したファイルがディレクトリなら真である。
-f　ファイル名	指定したファイルが通常ファイルなら真である。
-L　ファイル名	指定したファイルがシンボリックリンクなら真である。
-h  ファイル名	指定したファイルがシンボリックリンクなら真である。
-p　ファイル名	指定したファイルが名前付きパイプなら真である。
-S　ファイル名	指定したファイルがソケットなら真である。
-e　ファイル名	指定したファイルが存在すれば真である。
-s  ファイル名  指定したファイルのファイルサイズが0より大きければ真である。
-v　変数名      指定した変数名が定義されていれば真である。$をつけない。
--------------------------------------------------------------------------------
-r　ファイル名	指定したファイルが読み取り可能なら真である。
-u　ファイル名	指定したファイルにSetUIDがセットされていれば真である。
-g　ファイル名	指定したファイルにSetGIDがセットされていれば真である。
-k　ファイル名	指定したファイルにスティッキービットがセットされていれば真である。
-w　ファイル名	指定したファイルが書き込み可能なら真である。
-x　ファイル名	指定したファイルが実行可能なら真である。


================================================================================
文字列のチェック
================================================================================
形式			条件
--------------------------------------------------------------------------------
-n 文字列		文字列の長さが0より大きければ真である。
-z 文字列		文字列の長さが0であれば真である。
文字列1 = 文字列2	2つの文字列が等しければ真である。
文字列1 != 文字列2	2つの文字列が等しくなければ真である。


================================================================================
数値のチェック
================================================================================
形式			条件
--------------------------------------------------------------------------------
数値1　-eq　数値2	2つの数値が等しければ真である。
数値1　-ge　数値2	数値1が数値2以上であれば真である。
数値1　-gt　数値2	数値1が数値2より大きいのであれば真である。
数値1　-le　数値2	数値1が数値2以下であれば真である。
数値1　-lt　数値2	数値1が数値2未満であれば真である。
数値1　-ne　数値2	2つの数値が等しくなければ真である。


================================================================================
論理結合
================================================================================
形式		条件
--------------------------------------------------------------------------------
!条件		条件が偽であれば真である。
条件1　-a　条件2	条件1と条件2の両方が真であれば真である。
条件1　-o　条件2	条件1と条件2のどちらかが真であれば真である。
条件1　&&　条件2	条件1と条件2の両方が真であれば真である。
条件1　||　条件2	条件1と条件2のどちらかが真であれば真である。


================================================================================
[[condition]] と [conditionの違い]
================================================================================
[ "${hoge}" = "HOGE" ] <-> [[ ${hoge} = "HOGE" ]]
[[]]の場合$変数を""で括らなくて済む.


================================================================================
正規表現の判定(regexp)
================================================================================
attention1) [[]] (ダブルブラケット)でくくらないといけない.　
attention2) 正規表現部分は, ダブルクォーテーションでくくらない.

形式			条件
--------------------------------------------------------------------------------
[[ ${var} =~ ^a ]]	頭文字がaなら真
[[ ${var} =~ z$ ]]	尾文字がzなら真
[[ ${var} =~ ^[a-z] ]]	頭文字が小文字のアルファベットなら真
[[ ${var} =~ [a-z]$ ]]	尾文字が小文字のアルファベットなら真


================================================================================
エスケープシーケンス
================================================================================
書式	機能
--------------------------------------------------------------------------------
\n	改行
\t	タブ
\b	バック・スペース
\a	ビープ音

ex) $'と'で囲めばよい.
$ echo $'hoge\thoge\nhog\be'
hoge        hoge
hoe


================================================================================
リダイレクト&パイプ
================================================================================
書式				説明
--------------------------------------------------------------------------------
command > file			fileに出力
command >> file			fileにファイル末尾への追加
command < file			commandにfileを標準入力
command1 | command2		command1の出力をcommand2に入力
command1 | xargs command2	command1の出力をcommand2の引数にする
command | tee file		標準出力とファイルへの出力を同時に行う
command 2 > /dev/null 		標準出力のみを表示
command 1 > /dev/null		標準エラー出力のみを表示
command 2>&1			標準エラー出力を標準出力にまとめる
command 1>&2			標準出力を標準エラー出力にまとめる
command >/dev/null 2>&1		標準出力/標準エラー出力を/dev/nullへ
command1 2>&1 | command2	command1の標準出力/標準エラー出力をcommand2に入力

#EOF#